# 자바 동시성 제어 기법

동시성 제어는 여러 스레드가 동시에 실행될 때, 공유 자원에 대한 데이터 일관성을 보장하기 위해 필요하다.
이를 위해 자바는 다양한 동시성 제어 기법을 제공한다.
여기서는 `synchronized`, `ReentrantLock` 그리고 분산락, 비관적락, 낙관적락 등에 대해 간략하게 정리해보았다.

## 1. Synchronized

### 개요
- `synchronized`는 자바에서 가장 기본적인 동시성 제어 기법이다. 메소드나 특정 블록에 대해 간단히 락을 걸 수 있다.
- `암묵적`으로 락을 설정하므로, 락과 관련된 명시적인 관리가 필요 없다.

### 특징
- **자동 관리**: JVM이 락 획득 및 해제를 자동으로 관리한다.
- **간단한 구현**: 키워드 하나로 쉽게 동시성 제어를 구현할 수 있다.
- **단일 모니터 락**: 각 객체에 대해 단일 모니터 락을 사용하여 객체의 모든 `synchronized` 메소드가 동일한 락을 공유한다.

### 단점
- **세밀한 제어 부족**: 락의 세밀한 제어나 시도를 위한 기능이 없다.
- **데드락 위험**: 잘못 사용하면 데드락이 발생할 수 있다.

## 2. ReentrantLock

### 개요
- `ReentrantLock`은 자바 `java.util.concurrent.locks` 패키지에서 제공하는 클래스다. `synchronized`보다 더 세밀한 락 제어가 가능하다.
- `명시적`으로 락을 획득하고 해제해야 하므로 더 유연한 동시성 제어가 가능하다.
- `같은 스레드`에서 점유한 메서드 안에서 재귀 호출 등으로 인해 해당 락을 재점유해야할 때 유용하다.

### 특징
- **명시적인 락 관리**: 락을 직접 획득하고 해제할 수 있다.
- **공정성 설정**: 락의 공정성을 설정하여 더 오래 기다린 스레드가 우선 락을 획득하게 할 수 있다
- **타임아웃 기능**: 지정한 시간 동안만 락을 시도하는 타임아웃 옵션을 제공한다.
- **tryLock**: 락 획득을 시도하지만 이미 점유하고 있는 경우 즉시 false를 반환할 수 있다.

### 단점
- **복잡한 관리**: 명시적으로 락을 해제해야 하므로, 관리가 복잡할 수 있다. (AutoClosable을 구현하면 리소스가 종료될 때 자동으로 해제 가능할 지도..?)
- **데드락 위험**: 잘못 사용하면 데드락이 발생할 수 있다.

## 3. 비관적 락

### 개요
- 비관적 락은 데이터에 접근할 때 항상 충돌이 발생할 것이라고 가정하고, 자원을 차단한다.
- 데이터에 대한 변경이 빈번히 발생하는 경우 적합한다.

### 특징
- **락 기반**: 데이터를 읽거나 수정할 때 락을 획득하여 다른 스레드의 접근을 차단한다.
- **높은 충돌 회피**: 충돌이 자주 발생하는 환경에서 유리히다.

### 단점
- **성능 저하**: 락을 자주 획득하고 해제하기 때문에 성능에 심각한 문제가 생길 수 있다

## 4. 낙관적 락

### 개요
- 낙관적 락은 데이터 충돌이 거의 없을 것이라고 가정하고, 먼저 작업을 수행한 후 충돌이 발생하면 롤백하는 방식이다.
- 충돌이 적고, 읽기 작업이 많은 경우 적합한다.

### 특징
- **버전 관리 기반**: 데이터가 변경되는 동안 버전 번호를 확인하여 충돌을 탐지한다.
- **낮은 성능 부하**: 충돌이 적을 경우 높은 성능을 발휘한다.

### 단점
- **충돌 처리 복잡성**: 충돌이 발생하면 롤백이나 재시도가 필요하므로 복잡성이 증가한다.

## 5. 분산 락

### 개요
- 분산 환경에서 여러 노드가 동일한 자원에 대한 락을 획득할 수 있도록 보장하는 기법이다.
- `Redis`와 같은 분산 시스템에서 주로 사용한다.

### 특징
- **분산 시스템에서 사용**: 여러 서버에서 동시성 제어를 할 수 있다
- **레디스 기반 구현**: 주로 `RedLock`과 같은 구현을 통해 분산 락을 설정한다.

### 단점
- **구현 복잡성**: 네트워크나 노드 실패를 고려해야 하므로 복잡성이 증가한다.


## 결론

동시성 제어를 위해 존재하는 여러 방법들에 대해 찾아보게 되었다. 아직 코드레벨 단계에서 Synchronized, reentrantLock 정도 사용해봤지만
시스템 환경에 따라 더 다양한 방법이 있는 것을 알게 되었다.
적절한 동시성 제어를 통해 API, DB서버에 부하를 줄일 수 있어서 이번에 제대로 배워야겠다는 생각이 들었다.